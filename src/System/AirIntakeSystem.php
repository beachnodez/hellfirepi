<?php

namespace Coff\Hellfire\System;

use Casadatos\Component\Dashboard\ConsoleDashboard;
use Casadatos\Component\Dashboard\Gauge\PercentGauge;
use Casadatos\Component\Dashboard\Gauge\ValueGauge;
use Coff\DataSource\Exception\DataSourceException;
use Coff\Hellfire\ComponentArray\BoilerSensorArray;
use Coff\Hellfire\Event\CyclicEvent;
use Coff\Hellfire\ControlMap\AirIntakeControlMap;
use Coff\Hellfire\Servo\AnalogServo;
use Coff\Hellfire\StateEnum\AirIntakeStateEnum;
use Coff\SMF\Assertion\AlwaysFalseAssertion;

class AirIntakeSystem extends System
{
    use SensorArrayTrait;
    use DashboardTrait;
    use ExhaustSensorTrait;

    protected $exhaustTemp;
    protected $thermocoupleBroken=false;

    /** @var AnalogServo */
    protected $servo;

    /** @var AirIntakeControlMap */
    protected $intakeControlMap;

    public function init()
    {

        $this->getDashboard()
            ->add('Intk', new PercentGauge(7))
            ->add('Exhst', new ValueGauge(5))
            ->add('IntkState', new ValueGauge(10), null, ConsoleDashboard::COL_FG_WHITE)
        ;

        $this->open();

        $this->setInitState(AirIntakeStateEnum::ACTIVE());

        // transitions that never occur automatically while running but possible to be forced
        $this
            ->allowTransition(AirIntakeStateEnum::CLOSED(), AirIntakeStateEnum::OPENED(), new AlwaysFalseAssertion())
            ->allowTransition(AirIntakeStateEnum::OPENED(), AirIntakeStateEnum::CLOSED(), new AlwaysFalseAssertion())
            ->allowTransition(AirIntakeStateEnum::CLOSED(), AirIntakeStateEnum::ACTIVE(), new AlwaysFalseAssertion())
        ;

        // emergency transition
        $this
            ->allowTransition(AirIntakeStateEnum::OPENED(), AirIntakeStateEnum::ACTIVE())
            ;

        return parent::init(); // TODO: Change the autogenerated stub
    }

    public function assertOpenedToActive()
    {
        return ($this->sensorArray->getReading(BoilerSensorArray::SENSOR_HIGH()) > 85 || $this->exhaustTemp > 200) ? true : false;
    }

    public static function getSubscribedEvents()
    {
        $events = parent::getSubscribedEvents();

        $events[CyclicEvent::EVERY_3_SECOND] = 'every3s';
        $events[CyclicEvent::EVERY_10_MINUTE] = 'every10Minutes';

        return $events;
    }

    /**
     * @param CyclicEvent $event
     */
    public function every3s(CyclicEvent $event) {
        $this->update();
    }

    /**
     * Updates intake control map from map file
     * @param CyclicEvent $event
     * @throws DataSourceException
     */
    public function every10Minutes(CyclicEvent $event) {
        $this->intakeControlMap->update();
    }

    public function update()
    {
        $this->sensorArray->update();

        $this->getExhaustSensor()->update();
        $this->exhaustTemp = $this->getExhaustSensor()->getValue();

        $this->intakeControlMap->setBoilerTemp($this->sensorArray->getReading(BoilerSensorArray::SENSOR_HIGH()));
        $this->intakeControlMap->setExhaustTemp($this->exhaustTemp);

        $this->run();

        if ($this->isMachineState(AirIntakeStateEnum::ACTIVE())) {
            $value = $this->intakeControlMap->getValue();

            $this->servo->getRelative( $value / 100);
        }

        $this->getDashboard()
            ->update('Intk', sprintf("%.2f", $this->getServo()->getRelative() * 100))
            ->update('Exhst', sprintf("%d", $this->exhaustTemp))
            ->update('IntkState', $this->getState())
        ;
    }

    /**
     * Fully closes air intake valve
     */
    public function close() {
        $this->setMachineState(AirIntakeStateEnum::CLOSED());
        $this->logger->info('Shutter closed');
        $this->servo
            ->setRelative(0)
            ->send();
    }

    /**
     * Fully opens air intake valve
     */
    public function open() {
        $this->setMachineState(AirIntakeStateEnum::OPENED());
        $this->logger->info('Shutter opened');
        $this->servo
            ->setRelative(1)
            ->send();
    }

    /**
     * Performs one step down
     *
     * @param int $rel
     */
    public function stepDown($rel=1) {
        $this->servo
            ->stepDown($rel)
            ->send();
    }

    /**
     * Performs one step up by doing two steps up and one step down.
     *
     * It's due to boiler's air intake shutter's weight servo makes annoying
     * noises when stopped after pulling shutter upward.
     *
     * @param int $rel
     */
    public function stepUp($rel=1) {
        $this->servo
            ->stepUp(3)
            ->send();

        /**
         * We don't step down when at max because we'd never came to max so
         * servo's arm would go crazy trying.
         */
        if (false == $this->servo->isMax()) {
            usleep(50000);

            $this->servo
                ->stepDown($rel+1)
                ->send();
        }
    }


    /**
     * @param AnalogServo $servo
     * @return $this
     */
    public function setServo(AnalogServo $servo) {
        $this->servo = $servo;

        return $this;
    }

    /**
     * @return AnalogServo
     */
    public function getServo() {
        return $this->servo;
    }

    /**
     * @return AirIntakeControlMap
     */
    public function getIntakeControlMap()
    {
        return $this->intakeControlMap;
    }

    /**
     * @param AirIntakeControlMap $intakeControlMap
     * @return $this
     */
    public function setIntakeControlMap($intakeControlMap)
    {
        $this->intakeControlMap = $intakeControlMap;
        return $this;
    }

}
